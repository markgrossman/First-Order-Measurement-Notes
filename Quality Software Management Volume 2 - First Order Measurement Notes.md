## Preface
### Three fundamental abilities needed to do a quality job of managing software engineering:

1. The ability to understand complex situations so you can plan a project and then observe and act in order to keep the project going according to plan, or modify the plan
1. The ability to observe what's happening and to understand the significance of your observations in terms of effective adaptive actions
1. The ability to act appropriately in difficult interpersonal situations, even though you may be confused, or angry, or so afraid you want to run away and hide

First order measurements are just adequate to the task of getting something built (back of the envelope)

Second order measurements are used to optimize systems to make them cheaper or faster

You can't really use second order measurements until you're able get stuff out the door

##Introductions: A Model of Observation

Before we can measure anything, we must observe.

### The Interaction Model (Virginia Satir)

1. Intake
1. Meaning
1. Significance
1. Response


We can study another person's mind by noticing how that person responds to different things we say or do


##Part 1: Intake

The keyword for the intake step is precision - providing as stable a foundation as possible for building the rest of the observation process

### Why Observation is so Important

Many of the failures to manage software engineering can be traced to failures in observation. 

Managers under stress genuinely believe they are victims of a sudden crisis because, indeed, their _awareness_ of failure is sudden. In other words, the suddenness of the crisis is not a measure of the crisis, but _a measure of managers' awareness_

**Don't mistake the end of an illusion for the start of a crisis**

Classifying organizations by what people say they're doing:

0. Oblivious: We didn't even know that we're performing a process
1. Variable: We do whatever we feel like at the moment
2. Routine We follow our routines (except when we panic)
3. Steering: We choose among our routines by the results they produce
4. Anticipating: We establish routines based on our past experiences
5. Congruent: Everyone is involved in improving everything all the time

#####Oblivious culture

Doesn't systematically observe anything, no SDLC, so faults may be detected at any time or never

#####Variable culture

Typically observes faults after the fact

Failures will note be seen as information, and will simply be redefined as non-events

Often forget failures while remembering successes, thus producing a performance "history" distorted toward the optimistic end of the scale

#####Routine Organization

More likely to find a design fault before it results in a customer failure in use likely resulting from testing

Feeds back failure information back into the product rather than the organization (not good)

"If everybody simply followed the routine, nothing would ever go wrong. Therefore, if something does go wrong, somebody must have violated the rules"

This approach works effectively for straightforward problems, but fails at harder problems

The routine pattern is surprised by crisis

Measures much, but sees little

#####Steering Culture

The purpose of observation is to attempt to _invalidate_ models, not validate them

Observations may suggest a problem

React by not blaming people, but by gathering information

Earlier detection means reduced development and usage costs [^1]

#####Anticipating Culture

Places emphasis on preservation

Constantly seeking a better model for detecting, improving, acquiring, and retiring software [^2]

#####Congruent Culture [^3]

Appropriately applies the best of each of the other cultures

Everything it learns is applied throughout the organization


###Summary
Almost any time software engineering management fails, it fails because of quality problems in the process as well as the product


##Part 2: Selecting What To Observe

To survive, particularly in a Routine culture, managers need to many tricks for avoiding blame. And the best of all tricks is _not to notice_

[^1]: Seems like the more "Thought testing" you do at the design stages of development, the less actual testing you'll have to do at the end
[^2]: Continuous improvement
[^3]: Sounds like a software development utopia













